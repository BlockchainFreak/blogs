# Dockerization

## Common Flags

```-d``` - run the container in detached mode (in the background)

```-p 80:80``` - map port 80 of the host to port 80 in the container

```-t``` - gives a name tag to your docker image (for easy to remember names)

```-v``` - mount a volume

```-a``` - do the action for all files/images/volumes

```-f``` - force

## Common Commands

```docker run``` - run a container

**Example:** ```docker run -dp 80:80 docker/getting-started``` - run the getting-started image in detached mode and map port 80 of the host to port 80 in the container

```docker ps``` - list running containers

```docker ps -a``` - list all containers

```docker stop``` - stop a running container

```docker rm``` - remove a container

```docker rmi``` - remove an image

```docker images``` - list images

```docker exec -it``` - run a command in a running container

```docker build``` - build an image from a Dockerfile

```docker pull``` - pull an image or a repository from a registry

```docker push``` - push an image or a repository to a registry

```docker login``` - log in to a registry

```docker logout``` - log out from a registry

```docker search``` - search the Docker Hub for images

```docker tag``` - create a tag TARGET_IMAGE that refers to SOURCE_IMAGE

```docker version``` - show the Docker version information

```docker info``` - display system-wide information

```docker system df``` - show docker disk usage

```docker system prune``` - delete unused data

## Creating a docker file

### Simple but not recommended

    note in this case we are using a light weight linux distribution called alpine,
    node v18 alpine

```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY . .
RUN yarn install --production
CMD ["node", "src/index.js"]
```

- Each line is a new layer in the image
  - ```FROM``` - base image
  - ```WORKDIR``` - set the working directory
  - ```COPY``` - copy files from the host to the container
  - ```RUN``` - run a command in the container
  - ```CMD``` - set the default command to run when the container starts
- The Docker will try to cache the layers as much as possible
- This method is inefficient because it will copy all the files in the directory to the container even if only one file is changed and it will run the ```yarn install``` command even if the dependencies are not changed
- as a result, the build time will be long and the image size will be large

### Recommended

```dockerfile
FROM node:18-alpine
WORKDIR /app
```

Copy the package.json file and then install the dependencies

```dockerfile
COPY package*.json ./
RUN yarn install
```

Copy the rest of the files
```dockerfile
COPY . .
```

But This will also copy the node modules, hence we will use the ```.dockerignore``` file to ignore the node modules just like the ```.gitignore``` file

Set up some Environment Variables (if needed)
```dockerfile
ENV PORT=80
ENV NODE_ENV=production
```

You can Expose a port
```dockerfile
EXPOSE 8080
```

Set the default command to run when the container starts
```dockerfile
CMD ["node", "src/index.js"]
```
or
```dockerfile
CMD ["yarn", "start"]
```
depending upon the package.json file

NOTE: There can only be one CMD instruction in a Dockerfile. If you list more than one CMD then only the last CMD will take effect.

## Building a Docker Image

```docker build -t <name> <path to directory>``` - build an image from a Dockerfile.

```docker build -t <name> -f <path to Dockerfile> .``` - build an image from a Dockerfile in a different directory. (from the current directory)

For example, if you are logged in:

```docker build -t username/getting-started:1.1 .```

## Running a Docker Container

```docker run <tagname or image-id>```

However, this might not expose the port to the host machine, so we need to add the ```-p``` flag

```docker run -dp 5000:8000 username/getting-started``` - run the getting-started image in detached mode and map port 5000 of the host to port 8000 in the container

## Volumes

Volumes are the preferred mechanism for **persisting data** generated by and used by Docker containers making it **shared**. While bind mounts are dependent on the directory structure of the host machine, volumes are completely managed by Docker. Volumes have several advantages over bind mounts:

- Volumes are easier to **back up or migrate** than bind mounts.
- You can manage volumes using Docker CLI commands or the Docker API.
- Volumes work on both Linux and Windows containers.
- Volumes can be more **safely shared** among multiple containers.
- Volume drivers allow you to store **volumes on remote hosts or cloud providers**, to encrypt the contents of volumes, or to add other functionality.
- New volumes can have their content pre-populated by a container.
- Volumes are easier to use than bind mounts because volumes are managed in Docker and therefore do not depend on directory paths used on the host machine.

### Creating a Volume

```docker volume create <name>``` - create a volume

```docker volume ls``` - list volumes

```docker volume inspect <name>``` - inspect a volume

```docker volume rm <name>``` - remove a volume

### Mounting a Volume

```docker run -dp 5000:8000 -v <name>:/app <image>``` - mount a volume to an image

remember to map ports or run commands with args if needed.

## Docker Compose

Docker Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your applicationâ€™s services. Then, with a single command, you create and start all the services from your configuration.

### Creating a docker-compose.yml file

Suppose, we want to create node app that uses an SQL database. We can create a docker-compose.yml file to run both the containers. Provided that SQL database is mounted in a volume. (persistance and sharing)

```yml
version: "3.9"
# Each key in service is a container (a separate microservice)
services:
    web:
        build: .
        ports:
          - "5000:8000"
    db:
        image: "mysql"
        enviorment:
            MYSQL_ROOT_PASSWORD: password
        volumes:
            - db-data:/dbdata

volumes:
    db-data:
```

### Running the docker-compose.yml file

```docker-compose up``` - run the docker-compose.yml file

```docker-compose up -d``` - run the docker-compose.yml file in detached mode

```docker-compose down``` - stop and remove the containers

```docker-compose down -v``` - stop and remove the containers and volumes

```docker-compose down -v --rmi all``` - stop and remove the containers, volumes and images
